/* eslint no-cond-assign:0 */

var rules = {
    prefixLink: /^\[((?:.|\n)+?)\]\{@link\s+((?:.|\n)+?)\}/,
    link: /^\{@link\s+((?:.|\n)+?)\}/,
    prefixTutorial: /^\[((?:.|\n)+?)\]\{@tutorial\s+((?:.|\n)+?)\}/,
    tutorial: /^\{@tutorial\s+((?:.|\n)+?)\}/,
    text: /^[\s\S]+?(?=[\{\\<!\[_*`]| {2,}\n|$)/
};

/**
 * @private
 * Given an array-ish result returned by a regular expression,
 * cast it into a normal array so that deep equality returns
 * true when you would expect.
 *
 * @param {Object} regexResult the result of a regex
 * @returns {Array<string>} a normal array of strings
 */
function toArray(regexResult) {
    var array = [];
    for (var i = 0; i < regexResult.length; i++) {
        array.push(regexResult[i]);
    }
    return array;
}

/**
 * Lex tokens out of a string input that represents some JSDoc-embedded
 * text.
 *
 * @name lex
 * @param {string} text input text.
 * @returns {Array<Object>} array of lexed tokens.
 * @example
 * var result = lex('See {@link MyClass}.');
 * // returns
 * result = [
 *   {
 *     "type": "text",
 *     "capture": [
 *       " See "
 *     ]
 *   },
 *   {
 *     "type": "link",
 *     "capture": [
 *       "{@link MyClass}",
 *       "MyClass"
 *     ]
 *   },
 *   {
 *     "type": "text",
 *     "capture": [
 *       ".\n"
 *     ]
 *   }
 * ];
 */
module.exports = function(text) {

    var tokens = [], cap;

    while (text) {

        if (cap = rules.prefixLink.exec(text)) {
            text = text.substring(cap[0].length);
            tokens.push({
                type: 'prefixLink',
                capture: toArray(cap)
            });
            continue;
        }

        if (cap = rules.link.exec(text)) {
            text = text.substring(cap[0].length);
            tokens.push({
                type: 'link',
                capture: toArray(cap)
            });
            continue;
        }

        if (cap = rules.prefixTutorial.exec(text)) {
            text = text.substring(cap[0].length);
            tokens.push({
                type: 'prefixTutorial',
                capture: toArray(cap)
            });
            continue;
        }

        if (cap = rules.tutorial.exec(text)) {
            text = text.substring(cap[0].length);
            tokens.push({
                type: 'tutorial',
                capture: toArray(cap)
            });
            continue;
        }

        if (cap = rules.text.exec(text)) {
            text = text.substring(cap[0].length);
            tokens.push({
                type: 'text',
                capture: toArray(cap)
            });
            continue;
        }

        if (text) {
          throw new
            Error('Infinite loop on byte: ' + text.charCodeAt(0));
        }
    }

    return tokens;
};
